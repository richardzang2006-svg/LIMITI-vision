# 预备队视觉组学习笔记

## opencv基础学习

### 一、Mat

#### 1.基础mat类型

| 枚举常量   | 数值 | 含义                                |
| ---------- | ---- | ----------------------------------- |
| `CV_8UC1`  | 0    | 8 位无符号单通道（灰度）            |
| `CV_8UC3`  | 16   | 8 位无符号 3 通道（BGR 彩图）       |
| `CV_8UC4`  | 24   | 8 位无符号 4 通道（BGRA 带透明）    |
| `CV_32FC1` | 5    | 32 位浮点单通道（深度图、卷积特征） |
| `CV_32FC3` | 21   | 32 位浮点 3 通道（彩色图像处理）    |
| `CV_64FC1` | 6    | 64 位浮点单通道（矩阵运算、雅可比） |

#### 2.使用imread读取该图片，并使用imshow可视化该图片

```c++
int main() {
    // 读取图片
    cv::Mat image = cv::imread("example.jpg");

    // 检查图片是否成功加载
    if (image.empty()) {
        std::cout << "无法加载图片！" << std::endl;
        return -1;
    }

    // 显示图片
    cv::imshow("Display Image", image);

    // 等待按键（参数为0时，无限等待，直到用户按下任意键，返回该键的ASCII码）
    cv::waitKey(0);

}
```

### 二、摄像头和颜色

#### 1.VideoCapture类

```c++
int main() {
    // 创建 VideoCapture 对象并打开视频文件/默认摄像头
    VideoCapture cap("example.mp4/0");

    if (!cap.isOpened()) {
        std::cerr << "Error: Could not open " << std::endl;
        return -1;
    }

        Mat frame;
        while (true) {
        cap >> frame;
        if (frame.empty()) {
            break;
        }

		//对Frame进行处理
		pass
		
        imshow("Frame", frame);

        if (waitKey(30) == 27) {
            break;
        }
}

    cap.release();
    destroyAllWindows();
}
```

#### 2.HSV色彩空间

HSV中,H为色调，S为饱和度，V为明度

其中，常见色彩的范围为

| 颜色 | Hmin‐Hmax       | Smin‐Smax | Vmin‐Vmax | 备注                      |
| ---- | --------------- | --------- | --------- | ------------------------- |
| 红   | 0‐10 ＋ 170‐180 | 70‐255    | 50‐255    | 跨 0°，要两次 mask        |
| 橙   | 11‐25           | 70‐255    | 50‐255    | 易与红/黄混，可缩到 15‐20 |
| 黄   | 26‐34           | 70‐255    | 50‐255    | 室外阳光最强              |
| 绿   | 35‐85           | 70‐255    | 50‐255    | 植物、交通灯              |
| 青   | 86‐100          | 70‐255    | 50‐255    | Tiffany 蓝、泳池水        |
| 蓝   | 101‐130         | 70‐255    | 50‐255    | 天空、LOGO                |
| 紫   | 131‐170         | 70‐255    | 50‐255    | 舞台灯、葡萄              |
| 粉   | 160‐175         | 50‐200    | 180‐255   | 降 S 显“淡”               |
| 白   | 0‐180（任意）   | 0‐30      | 180‐255   | 高 V 低 S                 |
| 黑   | 0‐180（任意）   | 0‐255     | 0‐50      | 低 V                      |
| 灰   | 0‐180（任意）   | 0‐30      | 50‐180    | 介于黑/白之间             |

其中，红色跨越了180度分界，所以要做两次掩码

提取蓝色的核心处理代码为：

```c++
//hsv用来生成掩膜mask_blue,frame_out存储输出
Mat hsv,mask_blue,frame_out;

//hsv为hsv三通道数组
cvtColor(frame, hsv, COLOR_BGR2HSV);

//用inRange生成单通道掩膜mask_blue,将三通道数组中符合条件的像素设置为255,不符的设置为0
inRange(hsv,Scalar(100,70,50),Scalar(130,255,255),mask_blue);

//由于三通道与单通道无法直接&按位与，所以用bitwise函数让frame与自己在mask_blue区域内按位与，输出存储在
frmae_out中
bitwise_and(frame, frame, frame_out, mask_blue);

//展示得到的frame_out数组，为三通道mat型，只显示蓝色区域的像素
imshow("Blue", frame_out);

```

实现效果：

![image-20251117142641463](image-20251117142641463.png)



而对于跨越180度的红色，则需要取两段mask再进行合并：

```c++
Mat hsv,mask_red,frame_out;
cvtColor(frame, hsv, COLOR_BGR2HSV);

// 低红段
Mat mask1;
inRange(hsv, Scalar(0,   70, 50),
              Scalar(10, 255, 255), mask1);
// 高红段
Mat mask2;
inRange(hsv, Scalar(170, 70, 50),
              Scalar(180, 255, 255), mask2);
// 合并两段
mask_red = mask1 | mask2;          // 或者 bitwise_or(mask1, mask2, mask_red);

bitwise_and(frame, frame, frame_out, mask_red);
```

### 三、形态学操作

psss

### 四、使用鼠标指针交互来获取图片的某点的rgb值

pass

### 五、透视变换

pass

### 六、查阅学习几个坐标系

**世界坐标系**：由用户定义的三维世界坐标系，描述物体和相机在真实世界中的位置，原点可以任意选择。

**相机坐标系**：以相机的光心为坐标原点，x轴和y轴平行于图像坐标系的x轴和y轴，z轴为相机的光轴。

**图像坐标系**：与成像平面重合，以成像平面的中心（光轴与成像平面的交点）为坐标原点，x 轴和 y轴分别平行于成像平面的两条边。

**像素坐标系**：单位为像素，与成像平面重合，以成像平面的左上角顶点为原点，x 轴和 y 轴分别平行于图像坐标系的x轴和y轴。

#### 1.**世界坐标系→相机坐标系**

世界坐标系到相机坐标系的转换属于刚体变换，通过旋转和平移即可获得，其中旋转矩阵为 ，平移矩阵为 T。
$$
\begin{bmatrix}
x_c\\ y_c\\ z_c\\ 1
\end{bmatrix}
=
\begin{bmatrix}
R & T\\
0 & 1
\end{bmatrix}
\begin{bmatrix}
x_w\\ y_w\\ z_w\\ 1
\end{bmatrix}
$$


#### 2.**相机坐标系→图像坐标系**

从相机坐标系到图像坐标系满足透视投影关系：
$$
x = f \cdot \frac{x_c}{z_c}, \quad y = f \cdot \frac{y_c}{z_c}
\\
z_c\begin{bmatrix}
x\\ y\\ 1
\end{bmatrix}
=
\begin{bmatrix}
f & 0 & 0 & 0\\
0 & f & 0 & 0\\
0 & 0 & 1 & 0
\end{bmatrix}
\begin{bmatrix}
x_c\\ y_c\\ z_c\\ 1
\end{bmatrix}
$$

#### 3.**图像坐标系→像素坐标系**

像素坐标系的单位为pixel，其中像素坐标系的单位为pixel，其中 u_0,v_0 为成像平面中心点在像素坐标系下的坐标， d_x 和 d_y 分别表示在像素坐标系下， x 轴和 y 轴方向每个像素的物理尺寸。
$$
\left\{
\begin{aligned}
u &= u_0 + \frac{x}{d_x}\\[6pt]
v &= v_0 + \frac{y}{d_y}
\end{aligned}
\right.
\\
\begin{bmatrix}
u\\[6pt]
v\\[6pt]
1
\end{bmatrix}
=
\begin{bmatrix}
\frac{1}{d_x} & 0 & u_0\\[6pt]
0 & \frac{1}{d_y} & v_0\\[6pt]
0 & 0 & 1
\end{bmatrix}
\begin{bmatrix}
x\\[6pt]
y\\[6pt]
1
\end{bmatrix}
$$

#### 4.综合公式，我们就可以直接得到，从世界坐标系到像素坐标系的转换关系式：

![](v2-6688bcb1a394e69829b2d794d70a6f9d_1440w.png)

### 七、学习相机成像原理和对相机进行标定

#### 1.标定的目的：获得参数

| 参数组                   | 符号                       | 拿到后干什么                            |
| ------------------------ | -------------------------- | --------------------------------------- |
| **内参**                 | K（3×3）<br>fx, fy, cx, cy | 把“像素”↔“归一化像平面”互相转换         |
| **畸变系数**             | k1,k2,p1,p2\[,k3,k4,k5,k6] | 把“带畸变的像点”↔“无畸变的像点”互相校正 |
| **外参**（每张照片一套） | R（3×3）、t（3×1）         | 把“世界坐标系”↔“相机坐标系”互相平移旋转 |

#### 2.利用matlab进行标定，如图所示：

![](截图 2025-11-21 22-07-35.png)

得到标定结果后，保存在工作区，参数如图所示：

![](截图 2025-11-21 22-10-12.png)

手动复制至opencv,完成标定

### 八、学习pnp算法来进行测距

pass



## 滤波

### 一、常用滤波算法

#### 1.中值滤波

取小窗口中灰度的中值，可以很好的保持图像边缘。**对于高斯噪声，中值滤波效果不如均值滤波**。对于**椒盐噪声，特别是脉冲宽度小于窗口宽度的一半时，中值滤波效果较好**。对于有缓变的较长轮廓线物体的图像，采用方形或圆形窗口。对于包含有尖顶角物体的图像，用十字形窗口。窗口大小则以不超过图像中最小有效物体尺寸为宜。如果图像中点、线、尖角细节较多，则不宜采用中值滤波。

```c++
void cv::medianBlur(
    InputArray  src,     // 输入图（1、3、4 通道，8-bit 或 32-bit 浮点）
    OutputArray dst,     // 输出图（同尺寸、同类型）
    int         ksize    // 核大小，必须为正奇数 >1，例如 3、5、7...
);
```

#### 2.均值滤波

最朴素的线性低通滤波：把像素邻域（窗口）里所有像素求平均再写回去，起**快速平滑、降噪、降分辨率**作用，但**不保边**。椒盐噪声反而被“抹大”

```c++
void cv::blur(
    InputArray  src,                     // 输入图（任意通道，8U/32F）
    OutputArray dst,                     // 输出图（同尺寸、同类型）
    Size        ksize,                   // 核宽×高，(3,3)、(5,5)...
    Point       anchor = Point(-1,-1),   // 锚点，默认居中
    int         borderType = BORDER_DEFAULT // 边界填充方式
);
```

#### 3.高斯滤波

**“用高斯函数做加权平均”** 的线性低通滤波器，对**随机白噪声**，**高斯噪声**最优。但**不保边**，边缘、纹理同样被模糊。**对椒盐噪点无效**，反而把“黑-白”抹成“灰-灰”。**高频信号一刀切**，无法选择性去噪。

高斯模板为：

1  2  1
2  4  2   × 1/16
1  2  1

```c++
void cv::GaussianBlur(
    InputArray  src,
    OutputArray dst,
    Size        ksize,              // 核像素尺寸，必须正奇数 或 (0,0)
    double      sigmaX,             // 行方向标准差
    double      sigmaY = 0,         // 列方向，0 表示 =sigmaX
    int         borderType = BORDER_DEFAULT
);
```

#### 4.双边滤波

在高斯滤波中，仅考虑领域像素点的空间位置对待处理点的滤波权重，并没有考虑其灰度之对待处理点的滤波影响。双边滤波是一种**同时考虑领域像素的空间域和值域**对滤波影响的滤波器。空域权重**与滑窗中点越近，权重越大**。值域权重**与待处理点颜色越相近，权重越大**。双边滤波器的**权重参数根据图像灰度值而变化**，能够在抑制**随机白噪与椒盐噪声**的同时，**保持边缘**。

```c++
void cv::bilateralFilter(
    InputArray  src,        // 8-bit 或 32F，1/3 通道
    OutputArray dst,        // 同尺寸同类型
    int         d,          // 窗口直径（像素），>0 时生效；=0 时自动计算 sigmaSpace
    double      sigmaColor, // 值域标准差 σ_color
    double      sigmaSpace, // 空域标准差 σ_space
    int         borderType = BORDER_DEFAULT
);
```

双边滤波对比高斯滤波与中值滤波

| 滤波器   | 保边    | 对随机白噪 | 对椒盐噪 | 运行机制                  |
| -------- | ------- | ---------- | -------- | ------------------------- |
| **高斯** | ×       | 优秀       | 越抹越灰 | 线性加权（只看距离）      |
| **中值** | ○（好） | 一般       | 必杀     | 排序取中值（非线性）      |
| **双边** | ◎       | 良好       | 尚可     | 距离+颜色双权重（非线性） |



### 二、卡尔曼滤波

pass

